---
layout: post
title:  "https是如何实现安全通信的"
date: 2020-08-15 19:37:19 +0800
categories: Share
keywords: https
description: 安全的通信过程必须满足四个条件：机密性，完整性，身份认证，不可否认。那么https是如何做到的呢？
---

&#160; &#160; &#160; &#160; 安全的通信过程必须满足四个条件：机密性，完整性，身份认证，不可否认。https相较于http多了一次TLS/SSL协议，https的安全性就是基于TLS/SSL协议实现的。

<!--description-->  
## 什么样的通信过程是安全的？  
&#160; &#160; &#160; &#160; 安全的通信过程必须满足四个条件：机密性，完整性，身份认证，不可否认。
- 机密性
  - 即不可以明文传输，传输内容不能被破解，只能让信任的人解码
- 完整性
  - 传输内容不可以被篡改
- 身份认证
  - 请求者的身份必须保证不能被盗用
- 不可否认
  - 即不能否认已经发生过的行为，攻击者不能伪造请求

## HTTPS是如何做到通信安全的四个要点的？  
### 机密性
&#160; &#160; &#160; &#160; 对报文内容的加密即可保证内容在传输过程中不被窃取。加密有对称加密和分对称加密两种分类方式。对称加密效率高但是由于设计密钥的传输，所以密钥的安全性比较难保证。非对称加密使用私钥、公钥的密钥对的形式加解密，密钥的安全性可以保证但是性能低。为能保证机密性和性能，我们可以采用混合加密的方式来实现。非对称加密用于交换密钥，后续采用对称加密。  
&#160; &#160; &#160; &#160; 整个过程是这样的。首先通过随机算法产生一个会话级别的会话密钥（对称加密密钥），通过公钥加密。因为密钥的长度比较短使用非对称加密的性能消耗有限。然后另一方通过私钥解密获得会话密钥。这样双方都获得的对称加密的密钥，后续通信则使用对称加密的密钥加密。
### 完整性
&#160; &#160; &#160; &#160; 通过对称加密的方式我们的传输内容可以得到加密，但是攻击者可以在获取到更多密文后尝试组合、修改后发给服务端，这时就不能保证收到的内容是否为原始内容了。为了实现完整性TLS协议采用了摘要算法，将传输内容通过摘要算法生成摘要。只要对原文进行任何修改都会导致摘要的变化，从而保证内容的完整性。这个过程是基于机密性的基础之上的，只有保证内容的机密性才能保证摘要不能被修改。
### 身份认证和不可否认
&#160; &#160; &#160; &#160; 虽然有了机密性和完整性的保证，但是攻击者还是可以伪装为别人发送请求。于是TLS采用了数字签名的方式防止别人伪造身份。原理为：使用私钥加密摘要，使用公钥解密验证。只要客户端和服务端互相通过“签名”和“验签”验证对方身份之后就可以用混合加密的方式进行安全通信了。
## 公钥的信任
&#160; &#160; &#160; &#160; 虽然前面满足了安全通信的四个要素，但是别人还是可以伪装一个服务端通过伪造的公钥达到获取报文的目的。那么就需要一种手段保证公钥的正准确性。显然对公钥加密是行不通的，因为会再次陷入到保证密钥不被窃取的死循环中。为了解决这个问题就必须引入可信的公正的第三方颁发一个数字证书以证明公钥是可信的。这个第三方就是CA(Certificate Authority，证书认证机构)。小的CA可以让大的CA签名验证，最后的根CA只能够自己证明自己（根证书）。操作系统和浏览器都内置了各大CA的根证书。服务端端发过来证书时可以通过证书链一层一层验证，直到找到根证书，确定证书是可信的。  
## TLS1.2 ECDHE算法握手过程
1. 一阶段 
   1. 客户端发送Client Hello包含TLS版本、客户端随机数(Client Random)、密码套件列表和扩展列表
   2. 服务端返回Server Hello包含
      1. 确认TLS版本号、服务端随机数(Client Random)、确定使用的密码套件
      2. 服务端的证书
      3. 密钥交换算法（ECDHE），服务端公钥(Server Params)，另附摘要签名
      4. 服务器Hello完成
2. 二阶段 证书验证
    1. 证书逐级验证、证书公钥验证签名、服务端身份验证成功
    2. 向服务端发送密钥交换 客户端公钥(Client Params),
3. 三阶段 主密钥生成
   1. 客户端、服务端分别使用Client Params、Server Params通过ECDHE算法生成pre-master，然后使用client random、server random和pre-master用PRF伪随机算法计算出master secret(主密钥)，主密钥用于生成客户端发送会话密钥(client write key)、服务端发送会话密钥(server write key)
   2. 客户端向服务端发送“Change Cipher Spec”，之后改用会话密钥通信，再发送“Finished”把之前所有的握手数据摘要加密，服务端验证
   3. 服务端向客户度发送“Change Cipher Spec”和“Finished”，双方验证通过握手完毕